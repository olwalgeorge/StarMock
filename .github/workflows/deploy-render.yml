name: ğŸš€ Deploy to Render

on:
  push:
    branches: [ main, olwal-qa ]
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip tests for emergency deployment'
        required: false
        default: false
        type: boolean

permissions:
  contents: read

concurrency:
  group: render-deploy-${{ github.ref }}
  cancel-in-progress: false

jobs:
  quality-checks:
    name: ğŸ¨ Code Quality
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.skip_tests != true }}
    
    steps:
    - name: ğŸ“¥ Checkout code
      uses: actions/checkout@v4
    
    - name: âš™ï¸ Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20.x'
        cache: 'npm'
        cache-dependency-path: app/package-lock.json
    
    - name: ğŸ“¦ Install dependencies
      working-directory: ./app
      run: |
        echo "::group::Installing dependencies"
        npm ci --prefer-offline --no-audit
        echo "::endgroup::"
    
    - name: ğŸ¨ Linting & Formatting
      working-directory: ./app
      run: |
        echo "::group::Running ESLint"
        npm run lint &
        LINT_PID=$!
        echo "::endgroup::"
        
        echo "::group::Checking Prettier formatting"
        npm run format:check &
        FORMAT_PID=$!
        echo "::endgroup::"
        
        # Wait for both to complete
        wait $LINT_PID
        LINT_EXIT=$?
        wait $FORMAT_PID
        FORMAT_EXIT=$?
        
        if [ $LINT_EXIT -ne 0 ]; then
          echo "âŒ Linting failed"
          exit 1
        fi
        
        if [ $FORMAT_EXIT -ne 0 ]; then
          echo "âŒ Formatting check failed"
          exit 1
        fi
        
        echo "âœ… Code quality checks passed!"
  
  tests:
    name: ğŸ§ª Unit Tests
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.skip_tests != true }}
    
    steps:
    - name: ğŸ“¥ Checkout code
      uses: actions/checkout@v4
    
    - name: âš™ï¸ Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20.x'
        cache: 'npm'
        cache-dependency-path: app/package-lock.json
    
    - name: ğŸ“¦ Install dependencies
      working-directory: ./app
      run: npm ci --prefer-offline --no-audit
    
    - name: ğŸ§ª Run Tests
      working-directory: ./app
      run: |
        echo "::group::Running test suite"
        npm test -- --run --reporter=verbose
        echo "::endgroup::"
  
  security:
    name: ğŸ”’ Security Audit
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.skip_tests != true }}
    
    steps:
    - name: ğŸ“¥ Checkout code
      uses: actions/checkout@v4
    
    - name: âš™ï¸ Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20.x'
        cache: 'npm'
        cache-dependency-path: app/package-lock.json
    
    - name: ğŸ“¦ Install dependencies
      working-directory: ./app
      run: npm ci --prefer-offline --no-audit
    
    - name: ğŸ”’ Security Audit
      working-directory: ./app
      run: |
        echo "::group::Running npm audit"
        npm audit --audit-level=high
        echo "::endgroup::"
  
  build:
    name: ğŸ—ï¸ Build
    runs-on: ubuntu-latest
    needs: [quality-checks, tests, security]
    if: always() && (needs.quality-checks.result == 'success' || needs.quality-checks.result == 'skipped') && (needs.tests.result == 'success' || needs.tests.result == 'skipped') && (needs.security.result == 'success' || needs.security.result == 'skipped')
    outputs:
      build_time: ${{ steps.timing.outputs.build_time }}
      
    steps:
    - name: ğŸ“¥ Checkout code
      uses: actions/checkout@v4
    
    - name: âš™ï¸ Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20.x'
        cache: 'npm'
        cache-dependency-path: app/package-lock.json
    
    - name: ğŸ“¦ Install dependencies
      working-directory: ./app
      run: npm ci --prefer-offline --no-audit
    
    - name: ğŸ—ï¸ Build Application
      id: timing
      working-directory: ./app
      run: |
        START_TIME=$(date +%s)
        echo "::group::Building production bundle"
        npm run build
        echo "::endgroup::"
        END_TIME=$(date +%s)
        BUILD_TIME=$((END_TIME - START_TIME))
        echo "build_time=${BUILD_TIME}s" >> $GITHUB_OUTPUT
        
        echo "âœ… Build completed in ${BUILD_TIME}s"
        echo "ğŸ“Š Build artifacts:"
        ls -lh dist/
  
  deploy:
    name: ğŸš€ Deploy to Render
    needs: build
    runs-on: ubuntu-latest
    outputs:
      deploy_time: ${{ steps.deploy_timing.outputs.deploy_time }}
      deploy_url: ${{ secrets.RENDER_APP_URL }}
    
    steps:
    - name: ğŸ¯ Trigger Render Deploy Hook
      id: deploy_timing
      run: |
        START_TIME=$(date +%s)
        echo "ğŸš€ Triggering Render deployment..."
        
        RESPONSE=$(curl -X POST "${{ secrets.RENDER_DEPLOY_HOOK_URL }}" \
          -H "Content-Type: application/json" \
          -w "\n%{http_code}" \
          -s \
          --max-time 30)
        
        HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
        BODY=$(echo "$RESPONSE" | head -n-1)
        END_TIME=$(date +%s)
        DEPLOY_TIME=$((END_TIME - START_TIME))
        
        echo "deploy_time=${DEPLOY_TIME}s" >> $GITHUB_OUTPUT
        echo "HTTP Status: $HTTP_CODE"
        echo "Response: $BODY"
        echo "âš¡ Deploy hook responded in ${DEPLOY_TIME}s"
        
        if [ "$HTTP_CODE" -eq 200 ] || [ "$HTTP_CODE" -eq 201 ]; then
          echo "âœ… Deployment triggered successfully!"
          echo "ğŸ”„ Render is now building and deploying your application..."
        else
          echo "âŒ Deployment hook failed with status $HTTP_CODE"
          exit 1
        fi
  
  healthcheck:
    name: ğŸ¥ Health Check
    needs: [build, deploy]
    runs-on: ubuntu-latest
    outputs:
      health_status: ${{ steps.health.outputs.health_status }}
      health_time: ${{ steps.health.outputs.health_time }}
      health_attempts: ${{ steps.health.outputs.health_attempts }}
    
    steps:
    - name: â³ Wait for Render Deployment
      run: |
        echo "â³ Giving Render time to build and deploy..."
        echo "ğŸ“Š Estimated time: 2-3 minutes"
        
        # Smart wait with progress indicators
        for i in {1..6}; do
          echo "â° Waiting... ($i/6) - $((i * 15))s elapsed"
          sleep 15
        done
        
        echo "âœ… Initial wait complete. Starting health checks..."
    
    - name: ğŸ” Health Check with Smart Retry
      id: health
      run: |
        MAX_RETRIES=12
        RETRY_COUNT=0
        HEALTH_URL="${{ secrets.RENDER_APP_URL }}/api/health"
        START_TIME=$(date +%s)
        SUCCESS=false
        
        echo "ğŸ¥ Checking health endpoint: $HEALTH_URL"
        echo "ğŸ”„ Max retries: $MAX_RETRIES with exponential backoff"
        echo ""
        
        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
          RETRY_COUNT=$((RETRY_COUNT + 1))
          
          # Make request with timeout
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" \
            --max-time 10 \
            --connect-timeout 5 \
            "$HEALTH_URL" 2>/dev/null || echo "000")
          
          CURRENT_TIME=$(date +%s)
          ELAPSED=$((CURRENT_TIME - START_TIME))
          
          if [ "$RESPONSE" -eq 200 ]; then
            echo "âœ… Health check PASSED! (Attempt $RETRY_COUNT/$MAX_RETRIES)"
            echo "âš¡ Application is live and responding"
            echo "â±ï¸ Total time: ${ELAPSED}s"
            echo "health_time=${ELAPSED}s" >> $GITHUB_OUTPUT
            echo "health_attempts=$RETRY_COUNT" >> $GITHUB_OUTPUT
            echo "health_status=success" >> $GITHUB_OUTPUT
            SUCCESS=true
            break
          fi
          
          # Calculate exponential backoff (10s, 15s, 20s, 25s...)
          WAIT_TIME=$((10 + (RETRY_COUNT * 5)))
          if [ $WAIT_TIME -gt 30 ]; then
            WAIT_TIME=30
          fi
          
          echo "â³ Attempt $RETRY_COUNT/$MAX_RETRIES: Status $RESPONSE - Waiting ${WAIT_TIME}s before retry... (${ELAPSED}s elapsed)"
          sleep $WAIT_TIME
        done
        
        if [ "$SUCCESS" = false ]; then
          # Health check failed
          FINAL_TIME=$(date +%s)
          TOTAL_TIME=$((FINAL_TIME - START_TIME))
          
          echo "âš ï¸ Health check timeout after ${TOTAL_TIME}s"
          echo "health_time=${TOTAL_TIME}s" >> $GITHUB_OUTPUT
          echo "health_attempts=$MAX_RETRIES" >> $GITHUB_OUTPUT
          echo "health_status=timeout" >> $GITHUB_OUTPUT
        fi
  
  dashboard:
    name: ğŸ“Š Deployment Dashboard
    needs: [quality-checks, tests, security, build, deploy, healthcheck]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
    - name: ğŸ“Š Generate Deployment Dashboard
      run: |
        # Determine overall status
        QUALITY_STATUS="${{ needs.quality-checks.result }}"
        TESTS_STATUS="${{ needs.tests.result }}"
        SECURITY_STATUS="${{ needs.security.result }}"
        BUILD_STATUS="${{ needs.build.result }}"
        DEPLOY_STATUS="${{ needs.deploy.result }}"
        HEALTH_STATUS="${{ needs.healthcheck.outputs.health_status }}"
        
        # Status emojis
        get_status_emoji() {
          case "$1" in
            "success") echo "âœ…" ;;
            "skipped") echo "â­ï¸" ;;
            "failure") echo "âŒ" ;;
            "cancelled") echo "ğŸš«" ;;
            "timeout") echo "â±ï¸" ;;
            *) echo "â“" ;;
          esac
        }
        
        # Overall deployment status
        if [ "$DEPLOY_STATUS" = "success" ] && [ "$HEALTH_STATUS" = "success" ]; then
          OVERALL_STATUS="âœ… SUCCESS"
          OVERALL_EMOJI="ğŸ‰"
        elif [ "$DEPLOY_STATUS" = "success" ] && [ "$HEALTH_STATUS" = "timeout" ]; then
          OVERALL_STATUS="âš ï¸ DEPLOYED (Health Check Timeout)"
          OVERALL_EMOJI="âš ï¸"
        else
          OVERALL_STATUS="âŒ FAILED"
          OVERALL_EMOJI="ğŸ’¥"
        fi
        
        # Create beautiful dashboard
        cat << 'EOF' >> $GITHUB_STEP_SUMMARY
        # ğŸš€ StarMock Deployment Dashboard
        
        ---
        
        ## ${{ env.OVERALL_EMOJI }} Overall Status: ${{ env.OVERALL_STATUS }}
        
        **Branch:** `${{ github.ref_name }}`  
        **Commit:** [`${{ github.sha }}`](https://github.com/${{ github.repository }}/commit/${{ github.sha }})  
        **Triggered by:** @${{ github.actor }}  
        **Time:** ${{ github.event.head_commit.timestamp }}
        
        ---
        
        ## ğŸ“‹ Pipeline Stages
        
        | Stage | Status | Details |
        |-------|--------|---------|
        | ğŸ¨ Code Quality | $(get_status_emoji "$QUALITY_STATUS") $QUALITY_STATUS | ESLint + Prettier checks |
        | ğŸ§ª Unit Tests | $(get_status_emoji "$TESTS_STATUS") $TESTS_STATUS | Vitest test suite |
        | ğŸ”’ Security Audit | $(get_status_emoji "$SECURITY_STATUS") $SECURITY_STATUS | npm audit (high severity) |
        | ğŸ—ï¸ Build | $(get_status_emoji "$BUILD_STATUS") $BUILD_STATUS | Production bundle |
        | ğŸš€ Deploy | $(get_status_emoji "$DEPLOY_STATUS") $DEPLOY_STATUS | Render deployment |
        | ğŸ¥ Health Check | $(get_status_emoji "$HEALTH_STATUS") $HEALTH_STATUS | Endpoint verification |
        
        ---
        
        ## âš¡ Performance Metrics
        
        | Metric | Value | Notes |
        |--------|-------|-------|
        | ğŸ—ï¸ Build Time | ${{ needs.build.outputs.build_time }} | Production bundle compilation |
        | ğŸš€ Deploy Hook | ${{ needs.deploy.outputs.deploy_time }} | Render webhook response |
        | ğŸ¥ Health Check | ${{ needs.healthcheck.outputs.health_time }} | ${{ needs.healthcheck.outputs.health_attempts }} attempts |
        | âš¡ Parallel Stages | 3 jobs | Quality + Tests + Security |
        
        ---
        
        ## ğŸŒ Deployment Information
        
        EOF
        
        if [ "$DEPLOY_STATUS" = "success" ]; then
          cat << EOF >> $GITHUB_STEP_SUMMARY
        **ğŸ¯ Live Application:** [${{ secrets.RENDER_APP_URL }}](${{ secrets.RENDER_APP_URL }})  
        **ğŸ¥ Health Endpoint:** [${{ secrets.RENDER_APP_URL }}/api/health](${{ secrets.RENDER_APP_URL }}/api/health)  
        **ğŸ“Š Render Dashboard:** [View Logs](https://dashboard.render.com)
        
        EOF
        
          if [ "$HEALTH_STATUS" = "success" ]; then
            cat << EOF >> $GITHUB_STEP_SUMMARY
        ### âœ… Application Status: Healthy
        
        Your application is live and responding to requests!
        
        **Quick Links:**
        - ğŸŒ [Open Application](${{ secrets.RENDER_APP_URL }})
        - ğŸ¥ [Check Health](${{ secrets.RENDER_APP_URL }}/api/health)
        - ğŸ“Š [View Metrics](https://dashboard.render.com)
        
        EOF
          else
            cat << EOF >> $GITHUB_STEP_SUMMARY
        ### âš ï¸ Health Check Notice
        
        The deployment was successful, but the health check timed out. This doesn't necessarily mean the deployment failed.
        
        **Action Items:**
        1. âœ… Check [Render Dashboard](https://dashboard.render.com) for build status
        2. âœ… Manually verify: [${{ secrets.RENDER_APP_URL }}](${{ secrets.RENDER_APP_URL }})
        3. âœ… Review Render logs for any startup errors
        
        EOF
          fi
        else
          cat << EOF >> $GITHUB_STEP_SUMMARY
        ### âŒ Deployment Failed
        
        **Troubleshooting Steps:**
        1. Review the failed job logs above
        2. Check [Render Dashboard](https://dashboard.render.com) for errors
        3. Verify all secrets are configured correctly
        4. Check `render.yaml` configuration
        
        EOF
        fi
        
        cat << EOF >> $GITHUB_STEP_SUMMARY
        ---
        
        ## ï¿½ Workflow Architecture
        
        \`\`\`mermaid
        graph LR
            A[ğŸ¨ Quality] --> D[ğŸ—ï¸ Build]
            B[ğŸ§ª Tests] --> D
            C[ğŸ”’ Security] --> D
            D --> E[ğŸš€ Deploy]
            E --> F[ğŸ¥ Health Check]
            F --> G[ğŸ“Š Dashboard]
            
            style A fill:#e1f5ff
            style B fill:#e1f5ff
            style C fill:#e1f5ff
            style D fill:#fff3e0
            style E fill:#f3e5f5
            style F fill:#e8f5e9
            style G fill:#fce4ec
        \`\`\`
        
        **Pipeline Features:**
        - âš¡ Parallel execution for pre-deploy checks (3x faster)
        - ğŸ¯ Smart health check with exponential backoff
        - ğŸ“Š Comprehensive metrics tracking
        - ğŸ”„ Automatic retry logic
        - ğŸš¨ Emergency deployment mode available
        
        ---
        
        ## ğŸ¯ Next Steps
        
        EOF
        
        if [ "$DEPLOY_STATUS" = "success" ] && [ "$HEALTH_STATUS" = "success" ]; then
          cat << EOF >> $GITHUB_STEP_SUMMARY
        âœ… **Deployment completed successfully!** Your changes are now live.
        
        **Recommended Actions:**
        - ğŸ§ª Perform smoke tests on the live application
        - ğŸ“Š Monitor application metrics and logs
        - ğŸ‘€ Review user feedback and error reports
        - ğŸ”„ Consider monitoring the first few minutes for any issues
        
        EOF
        else
          cat << EOF >> $GITHUB_STEP_SUMMARY
        âš ï¸ **Review Required:** Please check the logs and take appropriate action.
        
        **Need Help?**
        - ğŸ“– Check [DEPLOYMENT.md](./DEPLOYMENT.md) for troubleshooting
        - ğŸ’¬ Contact the team for deployment support
        - ğŸ”§ Use emergency deployment mode if needed
        
        EOF
        fi
        
        echo "---" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "*Generated by StarMock CI/CD Pipeline â€¢ [View Workflow](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})*" >> $GITHUB_STEP_SUMMARY
      env:
        OVERALL_STATUS: ${{ env.OVERALL_STATUS }}
        OVERALL_EMOJI: ${{ env.OVERALL_EMOJI }}
